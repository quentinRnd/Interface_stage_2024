{
	"changes" : 
	[
		{
			"add_constraint" : "prime(7)"
		},
		{
			"add_constraint" : "candidate(9)"
		},
		{
			"add_variable" : 
			{
				"mutable" : false,
				"name" : "x",
				"type" : "bool"
			}
		},
		{
			"remove_constraint" : "prime#12(3)"
		},
		{
			"remove_constraint" : "prime#11(2)"
		}
	],
	"chr_space" : "/**\n * Prime numbers\n *\n * Use of the Sieve of Eratosthenes to calculate all prime numbers up to a given\n * maximum.\n */\n \n<CHR name=\"PRIMES\">\n\t<chr_constraint> prime(+int), candidate(+int)\n\t\n\tcandidate(1) <=> success();;\n\tcandidate(N) <=> candidate(N - 1), prime(N);;\n\t\n\tabsorb @ prime(Y) \\ prime(X) <=> (X % Y) == 0 | success();;\n</CHR>",
	"cpp_space" : "/*\nFrom line 8 to 15\nprime<prime( N )> { prime<prime( X )> } -->\ncandidate<candidate( N )> --> prime<prime( N )>, candidate<candidate( ( N - 1 ) )>\n\n(constraint) prime( ( +int ) ), persistent\n(constraint) ##candidate( ( +int ) ), persistent\n(rule) candidate( 1 ) <=> success ;;\n(rule) candidate( N ) <=> ( candidate( ( N - 1 ) ), prime( N ) ) ;;\n(rule) absorb @ prime( Y ) \\ prime( X ) <=> ( ( X % Y ) == 0 ) | success ;;\n(occ rule) [-candidate( 1 )#0][] --> success ;;\n(occ rule) [-candidate( N )#1][] --> ( candidate( ( N - 1 ) ), prime( N ) ) ;;\n(occ rule) absorb @ [-prime( X )#0][+prime( Y ), ( ( X % Y ) == 0 )] --> success ;;\n(occ rule) absorb @ [+prime( Y )#1][-prime( X ), ( ( X % Y ) == 0 )] --> success ;;\n\n(constraint store) prime( ( +int ) ), persistent\n(constraint store) candidate( ( +int ) ), persistent\n// Rule NO_NAME, active constraint candidate( 1 ), occurrence 0\nBegin candidate_0\n\tremove constraint candidate( 1 )\n\tsuccess\n\tgoto next goal constraint\nEnd\n// Rule NO_NAME, active constraint candidate( N ), occurrence 1\nBegin candidate_1\n\tremove constraint candidate( N )\n\tcandidate( ( N - 1 ) )\n\tprime( N )\n\tgoto next goal constraint\nEnd\n// Fail through\nBegin candidate_store\n\tStore constraint candidate\nGoto next goal constraint\n// Rule absorb, active constraint prime( X ), occurrence 0\nBegin prime_0\nIf empty store prime( Y ) Then goto prime_1\n\tMatching partner prime( Y )\n\t\tIf guard\n\t\t\t( ( X % Y ) == 0 )\n\t\t\t&& ( prime( Y ) != prime( X ) )\n\t\tThen guard\n\t\t\tremove constraint prime( X )\n\t\t\tsuccess\n\t\t\tgoto next goal constraint\n\t\tEnd guard\n\tEnd matching partner prime( Y )\nEnd\n// Rule absorb, active constraint prime( Y ), occurrence 1\nBegin prime_1\nIf empty store prime( X ) Then goto prime_store\n\tMatching partner prime( X )\n\t\tIf guard\n\t\t\t( ( X % Y ) == 0 )\n\t\t\t&& ( prime( X ) != prime( Y ) )\n\t\tThen guard\n\t\t\tstore constraint prime( Y )\n\t\t\tremove constraint prime( X )\n\t\t\tsuccess\n\t\t\tIf not alived prime( Y ) Then goto next goal constraint\n\t\t\tgoto next matching of prime( X )\n\t\tEnd guard\n\tEnd matching partner prime( X )\nEnd\n// Fail through\nBegin prime_store\n\tStore constraint prime\nGoto next goal constraint\n*/\n//----------------------- START INCLUDE HEADER ---------------------\n/**\n * Prime numbers\n *\n * Use of the Sieve of Eratosthenes to calculate all prime numbers up to a given\n * maximum.\n */\n \n//----------------------- END INCLUDE HEADER ---------------------\n#include <chrpp.hh>\nclass PRIMES {\n\tunsigned long int next_free_constraint_id = 1;\n\t//(constraint store) prime( ( +int ) ), persistent\npublic:\n\tstruct prime {\n\t\tusing Type = typename std::tuple< unsigned long int, chr::Logical_var_ground< int > >;\n\t\tusing Constraint_store_t = typename chr::Constraint_store_simple< Type, false >;\n\t\tclass Constraint_callback : public chr::Logical_var_imp_observer_constraint {\n\t\tpublic:\n\t\t\tConstraint_callback(PRIMES* space, typename Constraint_store_t::iterator& it) : _space(space), _it( std::move(it) ) { assert((space != nullptr) && _it.alive()); _it.lock(); }\n\t\t\tConstraint_callback(const Constraint_callback&) =delete;\n\t\t\tvoid operator=(const Constraint_callback&) =delete;\n\t\t\t~Constraint_callback() { if (!_space.expired() && _space->prime_constraint_store) _it.unlock(); }\n\t\t\tunsigned char run() override {\n\t\t\t\tif (_space.expired()) return 0;\n\t\t\t\tif (!_it.alive()) return 0;\n\t\t\t\tauto& cc = const_cast< Type& >(*_it);\n\t\t\t\tif ( _space->do_prime(cc, _it) == chr::ES_CHR::FAILURE ) { return 2; }\n\t\t\t\treturn 1;\n\t\t\t}\n\t\tprivate:\n\t\t\tchr::Weak_obj< PRIMES > _space;\n\t\t\ttypename Constraint_store_t::iterator _it;\n\t\t};\n\t};\nprivate:\n\tchr::Shared_obj< typename prime::Constraint_store_t > prime_constraint_store{ chr::make_shared< typename prime::Constraint_store_t >(\"prime\") };\n\t//(constraint store) candidate( ( +int ) ), persistent\npublic:\n\tstruct candidate {\n\t\tusing Type = typename std::tuple< unsigned long int, chr::Logical_var_ground< int > >;\n\t};\npublic:\n\tvolatile unsigned int _ref_use_count  = 0;///< Count of shared references\n\tvolatile unsigned int _ref_weak_count = 0;///< Count of weak references + (#shared != 0)\n\tPRIMES() { }\n\t~PRIMES() {\n\t\tprime_constraint_store.release();\n\t}\n\tstatic chr::Shared_obj<PRIMES> create() { return chr::make_shared<PRIMES>(); }\n\tchr::Constraint_stores_iterator<chr::Shared_obj<typename prime::Constraint_store_t>> chr_store_begin() { return chr::Constraint_stores_iterator(prime_constraint_store); }\n\ttypename prime::Constraint_store_t& get_prime_store() { return *prime_constraint_store; }\n\tchr::ES_CHR do_prime(typename prime::Type c_args, typename prime::Constraint_store_t::iterator c_it);\n\tchr::ES_CHR prime( chr::Logical_var_ground< int > arg0) {\n\t\tassert(!chr::failed() && (_ref_use_count >= 1));\n\t\tauto c_args = std::make_tuple(next_free_constraint_id++, arg0);\n\t\treturn do_prime(std::move(c_args), prime_constraint_store->end());\n\t}\n\tchr::ES_CHR do_candidate(typename candidate::Type c_args);\n\tchr::ES_CHR candidate( chr::Logical_var_ground< int > arg0) {\n\t\tassert(!chr::failed() && (_ref_use_count >= 1));\n\t\tauto c_args = std::make_tuple(next_free_constraint_id++, arg0);\n\t\treturn do_candidate(std::move(c_args));\n\t}\n};\nchr::ES_CHR PRIMES::do_candidate(typename candidate::Type c_args) {\n\tchr::Statistics::update_call_stack();\n\t[[maybe_unused]] candidate_call:\n\t// ***************************************************\n\t// candidate_0 <=> Rule NO_NAME, active constraint candidate( 1 ), occurrence 1\n\t[[maybe_unused]] candidate_0:\n\t{\n\t\tif (std::get<1>(c_args) != 1) goto candidate_1;\n\t\t// Body\n\t\tchr::Statistics::inc_nb_rules();\n\n\t\treturn chr::ES_CHR::SUCCESS;\n\t}\n\t// ***************************************************\n\t// candidate_1 <=> Rule NO_NAME, active constraint candidate( N ), occurrence 2\n\t[[maybe_unused]] candidate_1:\n\t{\n\t\tauto& N = std::get<1>(c_args);\n\t\t// Body\n\t\tchr::Statistics::inc_nb_rules();\n\t\tif (chr::ES_CHR::FAILURE == candidate( ( N - 1 ) )) return chr::ES_CHR::FAILURE;\n\t\tif (chr::ES_CHR::FAILURE == prime( N )) return chr::ES_CHR::FAILURE;\n\t\treturn chr::ES_CHR::SUCCESS;\n\t}\n\t// Store constraint\n\t[[maybe_unused]] candidate_store:\n\treturn chr::ES_CHR::SUCCESS;\n}\nchr::ES_CHR PRIMES::do_prime(typename prime::Type c_args, typename prime::Constraint_store_t::iterator c_it) {\n\tbool c_stored_before = !c_it.at_end();\n\tchr::Statistics::update_call_stack();\n\t[[maybe_unused]] prime_call:\n\t// ***************************************************\n\t// prime_0 <=> Rule absorb, active constraint prime( X ), occurrence 1\n\t[[maybe_unused]] prime_0:\n\t{\n\t\tif (prime_constraint_store->empty()) goto prime_1;\n\t\tauto& X = std::get<1>(c_args);\n\t\tauto it0_0 = prime_constraint_store->begin();\n\t\twhile ( !it0_0.at_end() ) {\n\t\t\tauto Y(std::get<1>(*it0_0));\n\t\t\t// Begin guard\n\t\t\tif (\n\t\t\t\t( std::get<0>(*it0_0) != std::get<0>(c_args) )\n\t\t\t\t&& ( ( X % Y ) == 0 )\n\t\t\t) {\n\t\t\t\tif (c_stored_before) {\n\t\t\t\t\tc_it.kill();\n\t\t\t\t}\n\t\t\t\t// Body\n\t\t\t\tchr::Statistics::inc_nb_rules();\n\n\t\t\t\treturn chr::ES_CHR::SUCCESS;\n\t\t\t} // End guard\n\t\t\t++it0_0;\n\t\t}\n\t}\n\t// ***************************************************\n\t// prime_1 <=> Rule absorb, active constraint prime( Y ), occurrence 2\n\t[[maybe_unused]] prime_1:\n\t{\n\t\tif (prime_constraint_store->empty()) goto prime_store;\n\t\tauto& Y = std::get<1>(c_args);\n\t\tauto it1_0 = prime_constraint_store->begin();\n\t\twhile ( !it1_0.at_end() ) {\n\t\t\tauto X(std::get<1>(*it1_0));\n\t\t\t// Begin guard\n\t\t\tif (\n\t\t\t\t( std::get<0>(*it1_0) != std::get<0>(c_args) )\n\t\t\t\t&& ( ( X % Y ) == 0 )\n\t\t\t) {\n\t\t\t\tit1_0.lock();\n\t\t\t\tif (!c_stored_before) {\n\t\t\t\t\tc_it = prime_constraint_store->add(c_args);\n\t\t\t\t\tc_stored_before = true;\n\t\t\t\t}\n\t\t\t\tc_it.lock();\n\t\t\t\tit1_0.kill();\n\t\t\t\t// Body\n\t\t\t\tchr::Statistics::inc_nb_rules();\n\n\t\t\t\tassert(c_stored_before);\n\t\t\t\tif (!c_it.alive()) {\n\t\t\t\t\tc_it.unlock();\n\t\t\t\t\tit1_0.unlock();\n\t\t\t\t\treturn chr::ES_CHR::SUCCESS;\n\t\t\t\t}\n\t\t\t\tc_it.unlock();\n\t\t\t\tit1_0.next_and_unlock();\n\t\t\t\tgoto it1_0_next;\n\t\t\t} // End guard\n\t\t\t++it1_0;\n\t\t\tit1_0_next:;\n\t\t}\n\t}\n\t// Store constraint\n\t[[maybe_unused]] prime_store:\n\t\tif (!c_stored_before) {\n\t\t\t(void) prime_constraint_store->add( std::move(c_args) );\n\t\t}\n\treturn chr::ES_CHR::SUCCESS;\n}\n//----------------------- START INCLUDE HEADER ---------------------\n//----------------------- END INCLUDE HEADER ---------------------\n\ntemplate <typename T>\nstd::vector<std::string> constraints(T & pb)\n{\n\tstd::vector<std::string> constraints;\n\tfor (auto it = pb.chr_store_begin(); !it.at_end(); ++it)\n\t\tconstraints.push_back(it.to_string());\n\treturn constraints;\n}\n    ",
	"space_name" : "PRIMES"
}