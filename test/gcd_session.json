{
	"changes" : 
	[
		{
			"add_constraint" : "gcd(25)"
		},
		{
			"add_constraint" : "gcd(15)"
		},
		{
			"add_constraint" : "gcd(11)"
		},
		{
			"remove_constraint" : "gcd#9(1)"
		},
		{
			"add_constraint" : "gcd(12)"
		},
		{
			"add_constraint" : "gcd(18)"
		}
	],
	"chr_space" : "/**\n * Greatest Common Divisor (Naive approach)\n *\n * The Greatest Common Divisor (GCD) of two integers is the largest\n * positive integer that divides the two numbers without a remainder.\n * For example, the GCD of 12 and 18 is 6.\n */\n\n<CHR name=\"GCD\">\n\t<chr_constraint> gcd(+unsigned long int), res(?unsigned long int)\n\tgcd1 @ gcd(0ul) <=> success();;\n\tgcd2 @ gcd(N) \\ gcd(M) <=> N <= M | gcd(M-N);;\n\tres  @ gcd(N) \\ res(M) <=> M %= N;;\n</CHR>",
	"cpp_space" : "/*\nFrom line 9 to 14\nres<res( M )> { gcd<gcd( N )> } --> built-in<N>\ngcd<gcd( N )> { res<res( M )>, gcd<gcd( M )> } --> built-in<N>, gcd<gcd( ( M - N ) )>\n\n(constraint) gcd( ( +unsigned long int ) ), persistent\n(constraint) res( ( ?unsigned long int ) ), persistent\n(rule) gcd1 @ gcd( 0ul ) <=> success ;;\n(rule) gcd2 @ gcd( N ) \\ gcd( M ) <=> ( N <= M ) | gcd( ( M - N ) ) ;;\n(rule) res @ gcd( N ) \\ res( M ) <=> M %= N ;;\n(occ rule) gcd1 @ [-gcd( 0ul )#0][] --> success ;;\n(occ rule) gcd2 @ [-gcd( M )#1][+gcd( N ), ( N <= M )] --> gcd( ( M - N ) ) ;;\n(occ rule) gcd2 @ [+gcd( N )#2][-gcd( M ), ( N <= M )] --> gcd( ( M - N ) ) ;;\n(occ rule) res @ [+gcd( N )#3][-res( M )] --> M %= N ;;\n(occ rule) res @ [-res( M )#0][+gcd( N )] --> M %= N ;;\n\n(constraint store) gcd( ( +unsigned long int ) ), persistent\n(constraint store) res( ( ?unsigned long int ) ), persistent\n// Rule gcd1, active constraint gcd( 0ul ), occurrence 0\nBegin gcd_0\n\tremove constraint gcd( 0ul )\n\tsuccess\n\tgoto next goal constraint\nEnd\n// Rule gcd2, active constraint gcd( M ), occurrence 1\nBegin gcd_1\nIf empty store gcd( N ) Then goto gcd_2\n\tMatching partner gcd( N )\n\t\tIf guard\n\t\t\t( N <= M )\n\t\t\t&& ( gcd( N ) != gcd( M ) )\n\t\tThen guard\n\t\t\tremove constraint gcd( M )\n\t\t\tgcd( ( M - N ) )\n\t\t\tgoto next goal constraint\n\t\tEnd guard\n\tEnd matching partner gcd( N )\nEnd\n// Rule gcd2, active constraint gcd( N ), occurrence 2\nBegin gcd_2\nIf empty store gcd( M ) Then goto gcd_3\n\tMatching partner gcd( M )\n\t\tIf guard\n\t\t\t( N <= M )\n\t\t\t&& ( gcd( M ) != gcd( N ) )\n\t\tThen guard\n\t\t\tstore constraint gcd( N )\n\t\t\tremove constraint gcd( M )\n\t\t\tgcd( ( M - N ) )\n\t\t\tIf not alived gcd( N ) Then goto next goal constraint\n\t\t\tgoto next matching of gcd( M )\n\t\tEnd guard\n\tEnd matching partner gcd( M )\nEnd\n// Rule res, active constraint gcd( N ), occurrence 3\nBegin gcd_3\nIf empty store res( M ) Then goto gcd_store\n\tMatching partner res( M )\n\t\tstore constraint gcd( N )\n\t\tremove constraint res( M )\n\t\tM %= N\n\t\tIf not alived gcd( N ) Then goto next goal constraint\n\t\tgoto next matching of res( M )\n\tEnd matching partner res( M )\nEnd\n// Fail through\nBegin gcd_store\n\tStore constraint gcd\nGoto next goal constraint\n// Rule res, active constraint res( M ), occurrence 0\nBegin res_0\nIf empty store gcd( N ) Then goto res_store\n\tMatching partner gcd( N )\n\t\tremove constraint res( M )\n\t\tM %= N\n\t\tgoto next goal constraint\n\tEnd matching partner gcd( N )\nEnd\n// Fail through\nBegin res_store\n\tStore constraint res\n\tSchedule constraint res with variable index 0\nGoto next goal constraint\n*/\n//----------------------- START INCLUDE HEADER ---------------------\n/**\n * Greatest Common Divisor (Naive approach)\n *\n * The Greatest Common Divisor (GCD) of two integers is the largest\n * positive integer that divides the two numbers without a remainder.\n * For example, the GCD of 12 and 18 is 6.\n */\n\n//----------------------- END INCLUDE HEADER ---------------------\n#include <chrpp.hh>\nclass GCD {\n\tunsigned long int next_free_constraint_id = 1;\n\t//(constraint store) gcd( ( +unsigned long int ) ), persistent\npublic:\n\tstruct gcd {\n\t\tusing Type = typename std::tuple< unsigned long int, chr::Logical_var_ground< unsigned long int > >;\n\t\tusing Constraint_store_t = typename chr::Constraint_store_simple< Type, false >;\n\t\tclass Constraint_callback : public chr::Logical_var_imp_observer_constraint {\n\t\tpublic:\n\t\t\tConstraint_callback(GCD* space, typename Constraint_store_t::iterator& it) : _space(space), _it( std::move(it) ) { assert((space != nullptr) && _it.alive()); _it.lock(); }\n\t\t\tConstraint_callback(const Constraint_callback&) =delete;\n\t\t\tvoid operator=(const Constraint_callback&) =delete;\n\t\t\t~Constraint_callback() { if (!_space.expired() && _space->gcd_constraint_store) _it.unlock(); }\n\t\t\tunsigned char run() override {\n\t\t\t\tif (_space.expired()) return 0;\n\t\t\t\tif (!_it.alive()) return 0;\n\t\t\t\tauto& cc = const_cast< Type& >(*_it);\n\t\t\t\tif ( _space->do_gcd(cc, _it) == chr::ES_CHR::FAILURE ) { return 2; }\n\t\t\t\treturn 1;\n\t\t\t}\n\t\tprivate:\n\t\t\tchr::Weak_obj< GCD > _space;\n\t\t\ttypename Constraint_store_t::iterator _it;\n\t\t};\n\t};\nprivate:\n\tchr::Shared_obj< typename gcd::Constraint_store_t > gcd_constraint_store{ chr::make_shared< typename gcd::Constraint_store_t >(\"gcd\") };\n\t//(constraint store) res( ( ?unsigned long int ) ), persistent\npublic:\n\tstruct res {\n\t\tusing Type = typename std::tuple< unsigned long int, chr::Logical_var< unsigned long int > >;\n\t\tusing Constraint_store_t = typename chr::Constraint_store_simple< Type, false >;\n\t\tclass Constraint_callback : public chr::Logical_var_imp_observer_constraint {\n\t\tpublic:\n\t\t\tConstraint_callback(GCD* space, typename Constraint_store_t::iterator& it) : _space(space), _it( std::move(it) ) { assert((space != nullptr) && _it.alive()); _it.lock(); }\n\t\t\tConstraint_callback(const Constraint_callback&) =delete;\n\t\t\tvoid operator=(const Constraint_callback&) =delete;\n\t\t\t~Constraint_callback() { if (!_space.expired() && _space->res_constraint_store) _it.unlock(); }\n\t\t\tunsigned char run() override {\n\t\t\t\tif (_space.expired()) return 0;\n\t\t\t\tif (!_it.alive()) return 0;\n\t\t\t\tauto& cc = const_cast< Type& >(*_it);\n\t\t\t\tif ( _space->do_res(cc, _it) == chr::ES_CHR::FAILURE ) { return 2; }\n\t\t\t\treturn 1;\n\t\t\t}\n\t\tprivate:\n\t\t\tchr::Weak_obj< GCD > _space;\n\t\t\ttypename Constraint_store_t::iterator _it;\n\t\t};\n\t};\nprivate:\n\tchr::Shared_obj< typename res::Constraint_store_t > res_constraint_store{ chr::make_shared< typename res::Constraint_store_t >(\"res\") };\npublic:\n\tvolatile unsigned int _ref_use_count  = 0;///< Count of shared references\n\tvolatile unsigned int _ref_weak_count = 0;///< Count of weak references + (#shared != 0)\n\tGCD() { }\n\t~GCD() {\n\t\tgcd_constraint_store.release();\n\t\tres_constraint_store.release();\n\t}\n\tstatic chr::Shared_obj<GCD> create() { return chr::make_shared<GCD>(); }\n\tchr::Constraint_stores_iterator<chr::Shared_obj<typename gcd::Constraint_store_t>,chr::Shared_obj<typename res::Constraint_store_t>> chr_store_begin() { return chr::Constraint_stores_iterator(gcd_constraint_store,res_constraint_store); }\n\ttypename gcd::Constraint_store_t& get_gcd_store() { return *gcd_constraint_store; }\n\ttypename res::Constraint_store_t& get_res_store() { return *res_constraint_store; }\n\tchr::ES_CHR do_gcd(typename gcd::Type c_args, typename gcd::Constraint_store_t::iterator c_it);\n\tchr::ES_CHR gcd( chr::Logical_var_ground< unsigned long int > arg0) {\n\t\tassert(!chr::failed() && (_ref_use_count >= 1));\n\t\tauto c_args = std::make_tuple(next_free_constraint_id++, arg0);\n\t\treturn do_gcd(std::move(c_args), gcd_constraint_store->end());\n\t}\n\tchr::ES_CHR do_res(typename res::Type c_args, typename res::Constraint_store_t::iterator c_it);\n\tchr::ES_CHR res( chr::Logical_var< unsigned long int > arg0) {\n\t\tassert(!chr::failed() && (_ref_use_count >= 1));\n\t\tauto c_args = std::make_tuple(next_free_constraint_id++, arg0);\n\t\treturn do_res(std::move(c_args), res_constraint_store->end());\n\t}\n};\nchr::ES_CHR GCD::do_gcd(typename gcd::Type c_args, typename gcd::Constraint_store_t::iterator c_it) {\n\tbool c_stored_before = !c_it.at_end();\n\tchr::Statistics::update_call_stack();\n\t[[maybe_unused]] gcd_call:\n\t// ***************************************************\n\t// gcd_0 <=> Rule gcd1, active constraint gcd( 0ul ), occurrence 1\n\t[[maybe_unused]] gcd_0:\n\t{\n\t\tif (std::get<1>(c_args) != 0ul) goto gcd_1;\n\t\tif (c_stored_before) {\n\t\t\tc_it.kill();\n\t\t}\n\t\t// Body\n\t\tchr::Statistics::inc_nb_rules();\n\n\t\treturn chr::ES_CHR::SUCCESS;\n\t}\n\t// ***************************************************\n\t// gcd_1 <=> Rule gcd2, active constraint gcd( M ), occurrence 2\n\t[[maybe_unused]] gcd_1:\n\t{\n\t\tif (gcd_constraint_store->empty()) goto gcd_2;\n\t\tauto& M = std::get<1>(c_args);\n\t\tauto it1_0 = gcd_constraint_store->begin();\n\t\twhile ( !it1_0.at_end() ) {\n\t\t\tauto N(std::get<1>(*it1_0));\n\t\t\t// Begin guard\n\t\t\tif (\n\t\t\t\t( std::get<0>(*it1_0) != std::get<0>(c_args) )\n\t\t\t\t&& ( N <= M )\n\t\t\t) {\n\t\t\t\tif (c_stored_before) {\n\t\t\t\t\tc_it.kill();\n\t\t\t\t}\n\t\t\t\t// Body\n\t\t\t\tchr::Statistics::inc_nb_rules();\n\t\t\t\tc_args = std::forward_as_tuple(next_free_constraint_id++, ( M - N ));\n\t\t\t\tc_stored_before = false;\n\t\t\t\tgoto gcd_call;\n\n\t\t\t\treturn chr::ES_CHR::SUCCESS;\n\t\t\t} // End guard\n\t\t\t++it1_0;\n\t\t}\n\t}\n\t// ***************************************************\n\t// gcd_2 <=> Rule gcd2, active constraint gcd( N ), occurrence 3\n\t[[maybe_unused]] gcd_2:\n\t{\n\t\tif (gcd_constraint_store->empty()) goto gcd_3;\n\t\tauto& N = std::get<1>(c_args);\n\t\tauto it2_0 = gcd_constraint_store->begin();\n\t\twhile ( !it2_0.at_end() ) {\n\t\t\tauto M(std::get<1>(*it2_0));\n\t\t\t// Begin guard\n\t\t\tif (\n\t\t\t\t( std::get<0>(*it2_0) != std::get<0>(c_args) )\n\t\t\t\t&& ( N <= M )\n\t\t\t) {\n\t\t\t\tit2_0.lock();\n\t\t\t\tif (!c_stored_before) {\n\t\t\t\t\tc_it = gcd_constraint_store->add(c_args);\n\t\t\t\t\tc_stored_before = true;\n\t\t\t\t}\n\t\t\t\tc_it.lock();\n\t\t\t\tit2_0.kill();\n\t\t\t\t// Body\n\t\t\t\tchr::Statistics::inc_nb_rules();\n\t\t\t\tif (chr::ES_CHR::FAILURE == gcd( ( M - N ) )) return chr::ES_CHR::FAILURE;\n\t\t\t\tassert(c_stored_before);\n\t\t\t\tif (!c_it.alive()) {\n\t\t\t\t\tc_it.unlock();\n\t\t\t\t\tit2_0.unlock();\n\t\t\t\t\treturn chr::ES_CHR::SUCCESS;\n\t\t\t\t}\n\t\t\t\tc_it.unlock();\n\t\t\t\tit2_0.next_and_unlock();\n\t\t\t\tgoto it2_0_next;\n\t\t\t} // End guard\n\t\t\t++it2_0;\n\t\t\tit2_0_next:;\n\t\t}\n\t}\n\t// ***************************************************\n\t// gcd_3 <=> Rule res, active constraint gcd( N ), occurrence 4\n\t[[maybe_unused]] gcd_3:\n\t{\n\t\tif (res_constraint_store->empty()) goto gcd_store;\n\t\tauto& N = std::get<1>(c_args);\n\t\tauto it3_0 = res_constraint_store->begin();\n\t\twhile ( !it3_0.at_end() ) {\n\t\t\tauto M(std::get<1>(*it3_0));\n\t\t\tit3_0.lock();\n\t\t\tif (!c_stored_before) {\n\t\t\t\tc_it = gcd_constraint_store->add(c_args);\n\t\t\t\tc_stored_before = true;\n\t\t\t}\n\t\t\tc_it.lock();\n\t\t\tit3_0.kill();\n\t\t\t// Body\n\t\t\tchr::Statistics::inc_nb_rules();\n\t\t\tif ((M %= N) == chr::ES_CHR::FAILURE) return chr::ES_CHR::FAILURE;\n\t\t\tassert(c_stored_before);\n\t\t\tif (!c_it.alive()) {\n\t\t\t\tc_it.unlock();\n\t\t\t\tit3_0.unlock();\n\t\t\t\treturn chr::ES_CHR::SUCCESS;\n\t\t\t}\n\t\t\tc_it.unlock();\n\t\t\tit3_0.next_and_unlock();\n\t\t}\n\t}\n\t// Store constraint\n\t[[maybe_unused]] gcd_store:\n\t\tif (!c_stored_before) {\n\t\t\t(void) gcd_constraint_store->add( std::move(c_args) );\n\t\t}\n\treturn chr::ES_CHR::SUCCESS;\n}\nchr::ES_CHR GCD::do_res(typename res::Type c_args, typename res::Constraint_store_t::iterator c_it) {\n\tbool c_stored_before = !c_it.at_end();\n\tchr::Statistics::update_call_stack();\n\t[[maybe_unused]] res_call:\n\t// ***************************************************\n\t// res_0 <=> Rule res, active constraint res( M ), occurrence 1\n\t[[maybe_unused]] res_0:\n\t{\n\t\tif (gcd_constraint_store->empty()) goto res_store;\n\t\tauto& M = std::get<1>(c_args);\n\t\tauto it0_0 = gcd_constraint_store->begin();\n\t\tif ( !it0_0.at_end() ) {\n\t\t\tauto N(std::get<1>(*it0_0));\n\t\t\tif (c_stored_before) {\n\t\t\t\tc_it.kill();\n\t\t\t}\n\t\t\t// Body\n\t\t\tchr::Statistics::inc_nb_rules();\n\t\t\tif ((M %= N) == chr::ES_CHR::FAILURE) return chr::ES_CHR::FAILURE;\n\t\t\treturn chr::ES_CHR::SUCCESS;\n\t\t}\n\t}\n\t// Store constraint\n\t[[maybe_unused]] res_store:\n\t\tif (!c_stored_before) {\n\t\t\tc_it = res_constraint_store->add( c_args );\n\t\t\tauto ccb = chr::Shared_x_obj< chr::Logical_var_imp_observer_constraint >(new typename res::Constraint_callback(this,c_it));\n\t\t\tchr::schedule_constraint_callback(std::get<1>(c_args), ccb);\n\t\t}\n\treturn chr::ES_CHR::SUCCESS;\n}\n//----------------------- START INCLUDE HEADER ---------------------\n//----------------------- END INCLUDE HEADER ---------------------\n\ntemplate <typename T>\nstd::vector<std::string> constraints(T & pb)\n{\n\tstd::vector<std::string> constraints;\n\tfor (auto it = pb.chr_store_begin(); !it.at_end(); ++it)\n\t\tconstraints.push_back(it.to_string());\n\treturn constraints;\n}\n    ",
	"space_name" : "GCD"
}